---
title: "More advanced optim example"
output: html_document
author: Peter Scully
date: "2024-06-03"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Setup
First, we need to import the relevant libraries:
```{r imports}
library(ggplot2)
```

## Objective Function

Let's start by creating the objective function we want to minimize.

Our goal is to minimize the MSE between our predicted y-values and the actual
y-values.
```{r obj_fxn}
# Note: This function is based heavily on the function from the first 
#       optimization exercise

# objective_function: measures residual sum of squares between predictions for
#                     given parameters and actual y-data
# Args: 
#   data: data.frame containing an x and y column 
#   par: numeric vector of three parameters for the polynomial used to make 
#        predictions
# Returns: numeric vector length 1 containing the MSE between predicted and
#          observed y
objective_function <- function(data, par) {
  
  predicted_y <- par[1] + par[2] * data$x + par[3] * (data$x)^2
  SE <- (predicted_y - data$y)^2
  MSE <- mean(SE)
  return(MSE)
  
}
```


## Getting Data
Now we need to get the data we want to fit from our csv. Let's also plot it
so we have an idea of what we're looking at:
```{r read_data}
data <- read.csv(file.path(here::here(), '02', 'example_data.csv'))
ggplot() + geom_point(data = data, aes(x = x, y = y))
```

## Using optim
Now, let's call optim to find the optimal parameters for fitting this function
```{r optim_call}
optim_output <- optim(par = c(0, 0, 0.75),
                      fn = objective_function,
                      data = data)
best_pars <- optim_output$par
```

Based on optim's output, it seems that the best fit for the model is: $y = `r round(best_pars[1], 3)` + `r round(best_pars[2], 3)`x + `r round(best_pars[3], 3)`x^2$. 

## Plotting Results

Let's see how this fit looks when plotted
```{r plotting}
# Before plotting, we need to get all the data to plot
# Let's start by getting the predicted y values
pred_data <- data.frame(data$x)
colnames(pred_data) <- "x"
pred_data$y <- best_pars[1] + 
               best_pars[2] * pred_data$x + 
               best_pars[3] * (pred_data$x)^2

# Now let's make our plot:
ggplot() + 
  geom_point(data = data, aes(x = x, y = y)) +
  geom_line(data = pred_data, aes(x = x, y = y))

```

This fit looks quite reasonable!